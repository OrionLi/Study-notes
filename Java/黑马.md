# 继承

把共性内容抽取到父类当中，提高代码的复用性

### 子类调用父类方法可以，除了构造方法

Dog可以调用Animal的构造方法，但是getset方法就不用重新写了，直接用就可以了（因为继承下来了）

### 父类的私有变量不可被子类使用，但是用getset操作还是可以的

### 继承中构造方法的访问特点

* 子类不能继承父类的构造方法，但是可以通过super调用
* 子类构造方法的第一行，有一个默认的super()；
* 默认先访问父类中无参的构造方法，再执行自己。
* 如果想要方法文父类有参构造，必须手动书写。

![image-20221017191539080](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017191539080.png)

![image-20221017191415201](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017191415201.png)

### this、super使用总结

* this:理解为一个变量，表示当前方法调用者的地址值
* super:代表父类存储空间

### 用this访问本类的其他构造

==用于给一些数据做默认值的时候用到==

在子类的构造方法中，只要有一个去访问父类就可以了（在其他构造当中默认第一行都是有一个隐藏的super()的）

![image-20221017193417122](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017193417122.png)

### 一个标准的Javabean类要包含：

1．类名见名知意
2．所有的成员变量都需要私有
3．构造方法（空参带全部参数的构造）
4.get/set

==（好像里面的方法都不用static？）==

==toString也是在Javabean类里面重写的==

### 带全部参数的构造是要父类加子类全都包含的

传递给父类的构造方法进行赋值

自己特有的在本类里面赋值

```java
//空参构造
publicManager(){
}
//带全部参数的构造
//父类 + 子类
public Manager(String id,String name,doublesalary,doublebouns){
	super(id,name,salary);
	this.bouns = bouns;
}
```

 父类变量有getset，子类就不用再写了，子类把自己独有的补上就行了

# 多态

## 理解

借用内部类的方式理解

【黑马程序员Java零基础视频教程_上部(2022新版Java入门，含斯坦福大学练习题+力扣算法题+大厂java面试题）】 【精准空降到 09:37】 https://www.bilibili.com/video/BV17F411T7Ao?p=141&share_source=copy_web&vd_source=a509fb44c892c9c55cbccbacad6d249b&t=577

## 多态的优势

### 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。

```java
Person p= new Student();
p.work();//业务逻辑发生改变时，后续代码无需修改
```

### 定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。
## 多态的弊端

### 不能调用子类的特有功能

原因是当调用成员方法时，首先是看父类中是否包含该方法，然后再调用子类重写的方法，如果父类没有，会直接报错

### 解决手段

变回==原来的==子类类型

### 问题又来了，我不知道上面的代码写了它是啥类型的咋办

可以用instanceof来判断,它返回的是布尔类型的值 

```java
if(a instanceof Dog){
    Dog d = (Dog) a;
    d.lookhome;
}else if(a instanceof Cat){
    Cat c = (Cat) a;
    c.catchMouse;
}
```

JDK14新特性

![image-20221017153106130](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017153106130.png)

Person类

![image-20221017155842764](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017155842764.png)

Application类

![image-20221017155849568](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017155849568.png)

# 权限修饰符的使用规则
## 实际开发中，一般只用private和public

* 成员变量私有
* 方法公开
* 特例：如果方法中的代码是抽取其他方法中共性代码，这个共性的代码你又不想让外界去使用，这个方法一般也私有。

# 代码块

## 局部代码块（已淘汰）

在方法里面的代码块，优先运行，碰到代码块的右括号就结束生命

优势是节省内存空间（因为用完就丢），但现在内存技术发达，所以不怎么用

## 构造代码块（不够灵活）

每创建一个对象就执行一次

下图代码块在Application类执行Student student = new Student();时执行

但是不够灵活，每次构造时都是强制执行

![image-20221017202212877](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017202212877.png)

### 在多个构造方法里有重复代码下的替代方案

1. 把重复代码写在一个构造方法当中，在其他的构造方法中就不用再写了，可以通过this关键字调用本类的其他构造，不知道的值(name和age)给个默认值就行了
2. 把重复代码抽取成一个方法，想用的时候调方法就可以了

![image-20221017203412274](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017203412274.png)

## 静态代码块（重点）

格式：static{}
特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、==只执行一次==
==使用场景：在类加载的时候，做一些数据初始化的时候使用。==

### 可以用来在学生管理系统提前添加一个用户信息，使用时就可以直接登录使用了（免去注册环节）

![image-20221017204526897](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017204526897.png)

因为静态里面只能用静态，所以集合也要用static修饰

### 但好像不用静态代码块也可以进行数据初始化？

![image-20221017205047927](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221017205047927.png)

==只要是方法，就有可能被别人反复地去调用，此时这样的集合可能在内存中有多个，而且有可能会在循环中被反复的添加==

main方法其实也是可以被我们手动调用的（以上图为例）

```java
App2.main(null);
```

# 抽象类（未看完全视频）

## 抽象类和抽象方法的注意事项

* 抽象类不能实例化
* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
* 可以有构造方法
* 抽象类的子类
  * 要么重写抽象类中的所有抽象方法
  * 要么是抽象类

# 接口

## 存在意义

### 有少部分子类不需要这个功能

假设有个Animal父类，我们抽取的共性方法有吃饭，喝水和游泳，它的子类有兔子，青蛙和狗。但有个问题：

==兔子不会游泳啊！==

### 用统一规范 书写各自实现的方法 的格式

我们要实现的方法是游泳，但是A老哥觉得方法起名叫swim好，B老哥觉得起名叫swimming更恰当

==但是如果使用接口，那他们就要用接口定义的规则来书写==

### 需要一个对象来干活，但对象间是什么关系无所谓

public void 搬家(运输的接口 c)

* 搬家(车的对象)
* 搬家(搬家公司)

==是不是继承关系无所谓，反正这活得有东西干== 

### 接囗就是一种规则,是对行为的抽象

**接口的定义和使用**

* 接口用关键字interface来定义
  public interface 接口名{}

* 接口不能实例化

* 接口和类之间是实现关系，通过implements关键字表示
  public class 类名 implements 接口名{}

* 接口的子类（实现类）
  要么重写接口中的所有抽象方法
  要么是抽象类

  

注意1：接口和类的实现关系，可以单实现，也可以多实现。
	public class 类名 implements 接口名1, 接口名2{}

注意2：实现类还可以在继承一个类的同时实现多个接口。
	public class 类名 extends 父类 implements 接口名1, 接口名2{}

## 接口中成员特点

==默认：你不写Java也会帮你加上==

* 成员变量

  ​	规则不可变，所以成员变量只能是常量

  ​	==默认修饰符==：public(这个就不用说了) static(静态方便调用) final

* 构造方法：==没有==

  ​	接口不能创建对象，接口当中也不需要给子类的成员变量赋值，所以用不着构造方法

* 成员方法

  ​	只能是抽象方法
  ​	==默认修饰符==：public abstract

* JDK7以前：接口中只能定义抽象方法。
* JDK8的新特性：接口中可以定义有方法体的方法
* JDK9的新特性：接口中可以定义私有方法。

## 接口和类之间的关系
* 类和类的关系
  继承关系，只能单继承，不能多继承，但是可以多层继承

* 类和接口的关系
  实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

  ==多个接口的重名方法实现：重写一个就行了==

* 接口和接口的关系
  继承关系，可以单继承，也可以多继承

  ==如果实现类实现了最下面的子接口，那么就需要重写所有的抽象方法==

# 接口和抽象类练习

继承：子类是父类中的一种
隐含的味道：
一个父类中所有的子类需要是同一种事物

![image-20221018131035597](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221018131035597.png)

# 有关接口的其他知识

### JDK7以前，接口中只能定义抽象方法。

## 接口中新增方法

### JDK8以后接口中可以定义有方法体的方法。
（默认、静态）

* 允许在接口中定义默认方法，需要使用关键字default修饰
  作用：解决接口升级的问题

  

接口中默认方法的定义格式：

* 格式，public default 返回值类型 方法名（参数列表）{}
* 范例：public default void show(){}

接口中默认方法的注意事项：

* 默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字
* ==public可以省略，default不能省略==
* 如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写

### JDK9以后接口中可以定义私有方法（普通用、静态用）

接口中私有方法的定义格式：

**普通的私有方法，给默认方法服务的**

* 格式1：private 返回值类型 方法名(参数列表){}
  范例1：private void show(){}

**静态的私有方法，给静态方法服务的**

* 格式2，private static返回值类型方法名(参数列表){}
  范例2，private static void method(){}

**以这种形式，我们就可以把某些重复代码提取成一个方法，给其他要用到这些重复代码的方法去调用，同时不让外界去调用这些重复代码（好比长长的日志文件）**

## 适配器设计模式

1．当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式
2，书写步骤：
编写中间类XXXAdapter,实现对应的接口
对接口中的抽象方法进行空实现
让真正的实现类继承中间类，并重写需要用的方法
为了避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰

### 示例

假如我现在有一个接口，我只想用它的第五个方法

```java
public interface Inter {
    public abstract void method1();
    public abstract void method2();
    public abstract void method3();
    public abstract void method4();
    public abstract void method5();
}
```

但是这样直接实现的话我们被迫要重写五次方法

所以要用到适配器设计模式：在接口和想要实现的类中间新建一个类实现接口

==用abstract不让外界创建它的对象==

```java
public abstract class InterAdapter implements Inter{
    @Override
    public void method1() {
        
    }
    
    @Override
    public void method2() {
        
    }
    
    @Override
    public void method3() {
        
    }
    
    @Override
    public void method4() {
        
    }
    
    @Override
    public void method5() {
        
    }
}
```

==但只是空实现==

然后让实现类改为继承这个接口

```java
public class InterImpl extends InterAdapter{
    @Override
    public void method5() {
        sout.....
    }
}
```

==我要用到哪个方法，就重写哪个方法就可以了==

# 内部类

### 类的五大成员：
属性、方法、构造方法、代码块、内部类

### 内部类的访问特点
内部类可以直接访问外部类的成员，包括私有
外部类要访问内部类的成员，必须创建对象

### 以ArrayList中的迭代器引出对内部类的理解

汽车和引擎是相对独立的（汽车牌子，汽车性能，引擎牌子，引擎性能），但引擎又属于汽车的一部分（不能单独出现），所以我们要在汽车这个类里面建一个引擎这个内部类

## 成员内部类（知道怎么写就行）

* 写在成员位置的，属于外部类的成员：和属性（也就是成员变量）并列写在一起
* 也因此，修饰成员变量的，也可以拿来修饰成员内部类，比如：private,默认,protected,public等（static的叫静态内部类）
* 用法相当于一个成员变量
* 在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。

### 获取成员内部类对象
方式一：内部类是private时 -> 在外部类中编写方法，对外提供内部类的对象。

```java
public class Outer {
    public Inner getInstance(){
        return new Inner();
    }
}
```

```java
public class Application{
    Outer o = new Outer();
    o.getInstance;
}
```



方式二：内部类不是private时 -> 直接创建格式：外部类名.内部类名 对象名=外部类对象.内部类对象；

> 【黑马程序员Java零基础视频教程_上部(2022新版Java入门，含斯坦福大学练习题+力扣算法题+大厂java面试题）】 【精准空降到 09:37】 https://www.bilibili.com/video/BV17F411T7Ao?p=141&share_source=copy_web&vd_source=a509fb44c892c9c55cbccbacad6d249b&t=577

### 调用变量（易错！）

==人不是心脏的爹，所以心脏想调用人的参数不能用super！==

![image-20221018211152220](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221018211152220.png)

## 静态内部类（能看懂就行）

### 说明

静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。

### 创建静态内部类对象的格式

外部类名.内部类名 对象名 = new 外部类名.内部类名()；

### 调用非静态方法的格式

先创建对象，用对象调用
### 调用静态方法的格式

外部类名.内部类名.方法名()；

==与上面局部内部类不同的是，我们调用的是静态内部类Inner，其中show1是Inner中的非静态方法，show2是Inner中的静态方法==

![image-20221018214631990](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221018214631990.png)

![image-20221018215024479](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221018215024479.png)

### 概括总结

如何调用静态内部类中的方法？

* 非静态方法：先创建对象，用对象调用
* 静态方法：外部类名.内部类名，方法名()；

## 局部内部类（能看懂就行，没啥用）

局部内部类

1. 将内部类定义在方法里面就叫做局部内部类,==类似于方法里面的局部变量==。==（和局部变量同等地位哈）==
2. 外界无法直接使用，需要在方法内部创建对象并使用。
3. 该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

## 匿名内部类（重点掌握）

匿名内部类本质上就是隐藏了名字的内部类,==用于替代那些只会用一次的类==

对于==一个接口的匿名内部类==，一共要包含三个部分

> 继承或实现，方法重写，创建对象。

==它的整体就是一个类的子类对象或者接口的实现类对象！==

### 示例

现在我们有一个接口

```java
public interface Swim {
    public abstract void swim();
}
```

然后我们来整个匿名内部类把接口实现下

```java
public static void main（String[] args）{
    /*
    new 类名或接口名(){
    重写方法;
    };
    */
    new Swim(){
        //Swim()后面的是一个匿名内部类，通过new Swim()来创建它的对象
        @Override
        public void swim(){
            System.out.println("重写了游泳的方法")
        }
    };
}
```

格式和new 类名();是差不多的，所以别把分号忘了

==而一个抽象类与它的匿名内部类则是继承关系==

```java
new Animal(){
    @Override
    public void eat(){
    	System.out.println("重写了eat的方法")
    }
};
```

### 使用场景
**当方法的参数是接口或者类时，
以接口为例，可以传递这个接口的实现类对象，
如果实现类只要使用一次，就可以用匿名内部类简化代码**

```java
	method(
		new Animal() {
        	@Override
        	public void eat() {
            	sout.......
        	}
    	}//传的参数不用带分号
	);//方法后面要有分号

public static void method(Animal a){
    //Animal a是子类对象，所以这里用了多态
    a.eat();
}
```



```java
//也可以赋值给一个swim类型的变量
Swim s = new Swim(){
	@Override
	public void swim(){
		System.out.println("重写了游泳的方法")
	}
};
```

# 阶段项目：拼图游戏

## 精简main

### 用extends替换Application中的高代码量类

按照以往的方式（学生管理系统），我们是在main里面调用登录方法什么的然后在下面写登录方法

==但现在，我们是要new一个JFrame作登录页面,并且里面包含的业务逻辑还挺多的==

那有没有更好的解决方法？

有，==extends==

> //LoginJFrame表示登录界面
> //以后所有跟登录相关的代码，都写在这里

```java
public class LoginJFrame extends JFrame {
    //获取用户输入的用户名
	//获取用户输入的密码
	//生成一个验证码
	//获取用户输入的验证码
	//比较用户．密码，验证码
	//300多行
}
```

然后main里面,==如果我们想要开启一个界面，就创建谁的对象就可以了==

```java
public static void main(String[] args){
    new LoginJFrame();
}
```

### new时候的初始化

这个时候，我们登陆界面的设置要在new的时候完成，所以我们要在无参构造方法中设置

==this表示当前创建的这个对象的地址值==

```java
public class LoginJFrame extends JFrame{
    public LoginJFrame(){
        //在创建登录界面的时候，同时给这个界面去设置一些信息
		//比如把宽、高直接展示出来
        this.setSize(488,430);
		this.setVisibie(true);
    }
}
```

![image-20221019151909776](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019151909776.png)

==写到最后：指程序最后==

## 菜单制作

### 1. 先创建JMenuBar -> 菜单长条

```java
JMenuBar jMenuBar = new JMenuBar();
```

### 2. 再创建Jmenu -> 功能位

![image-20221019153118414](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019153118414.png)

### 3. 再创建JMenuItem -> 拓展栏

![image-20221019153436203](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019153436203.png)

### 4. 把JMenuItem放到Jmenu里面

![image-20221019153603275](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019153603275.png)

### 5. 把JMenu放到JMenuBar里面

![image-20221019153622485](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019153622485.png)

### 6. 最后再把JMenuBar添加到整个Jframe界面中

![image-20221019154023618](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019154023618.png)

## 抽取方法：ctrl + alt + m

==init：初始化==

![image-20221019154400746](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019154400746.png)

然后把上面“菜单制作”的全部内容（不包含this.setVisible）同样操作

![image-20221019154919997](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019154919997.png)

## 添加图片

### 取消默认居中

![image-20221019162731760](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019162731760.png)

### 选择模块名，然后ctrl+ v

==同样也是抽取方法==

![image-20221019160011668](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019160011668.png)

### 使用循环改进

![image-20221019161737172](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019161737172.png)

### 循环中定位图片名称

在外层循环写上int number = i;

在内层循环写上number++；

![image-20221019162034961](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019162034961.png)

因为我们只有15张图，所以找不到第16张图的时候它就加载了一个空白

## 打乱图片

### ramdom中的nextInt方法：闭区间

可以直接用r.nextInt(tempArr.length);

### 按顺序添加到位置

**解法一：适用于行列相等的二维数组**

![image-20221019164932338](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019164932338.png)

==注意：int的除法指保留整数，所以15/3=3==

**解法二：适用于行列不相等的二维数组**

![image-20221019165331380](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019165331380.png)

## TODO：阶段项目5及以后

# 常用API

## Math

![image-20221019170515249](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019170515249.png)

## System

![image-20221019171952033](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019171952033.png)



拷贝过去的数组好像是直接覆盖对应位置而不是像StringBuilder的insert一样

![image-20221019171017859](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019171017859.png)

![image-20221019171854256](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019171854256.png)

赋给父类类型的子类类型，在要获取的时候，得强转才行

## Rumtime

![image-20221019172108378](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019172108378.png)

## Object

![image-20221019172314830](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221019172314830.png)

clone的用途：游戏数据转区

直接实现就行，这接口是Java自带的

clone在lang包下是protected的，所以我们要把他给重写了，顺便调用父类的方法把东西返回回去

![image-20221020130743981](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020130743981.png)

![image-20221020130721163](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020130721163.png)

![image-20221020124848418](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020124848418.png)

浅克隆：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来

深克隆：基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的

Object中的克隆是浅克隆，只复制地址值

所以咱重写个深克隆

![image-20221020133113507](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020133113507.png)

==以后对象的克隆：导jar包：gson-2.6.2.jar==

![image-20221020133632759](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020133632759.png)

![image-20221020134013172](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020134013172.png)

```java
boolean result = Objects.equals(s1, s2);
System.out.println(result);
```

细节：

1. 方法的底层会判断sl是否为null，如果为null，直接返回false
2. 如果s1不为null，那么就利用sl再次调用equals方法

3. 此时s1是Student类型，所以最终还是会调用Student中的equals方法。
   如果没有重写，比较地址值，如果重写了，就比较属性值。

## BigInteger

【黑马程序员Java零基础视频教程_上部(2022新版Java入门，含斯坦福大学练习题+力扣算法题+大厂java面试题）】 https://www.bilibili.com/video/BV17F411T7Ao?p=161&share_source=copy_web&vd_source=a509fb44c892c9c55cbccbacad6d249b

![image-20221020135352179](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020135352179.png)

![image-20221020135526367](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020135526367.png)

第七点想返回long类型的话

![image-20221020135451587](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020135451587.png)

## BigDecima（没看）

## 正则表达式

### 应用场景

1. 正则表达式可以校验字符串是否满足一定的规则，并用来校验数据格式的合法性
2. 在一段文本中查找满足要求的内容

### 示例

* 需求：假如现在要求校验一个qq号码是否正确

* 规则：6位及20位之内，0不能在开头，必须全部是数字
       先使用目前所学知识完成校验需求
       然后体验一下正则表达式检验

* 发现如果用已学知识来做的话

  * 进行if嵌套
  * ==布尔逐步校验return false（好用！但是代码量大）==

  * 核心思想是：先把异常数据进行过滤，下面的就是满足要求的数据了。

* 用正则表达式

  ```java
  System.out.println(qq.matches("[1-9]\\d{5,19}"));
  ```

### 规则

![image-20221020185536091](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020185536091.png)

**字符类**

![image-20221020185930443](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020185930443.png)

![image-20221020190402422](C:\Users\84185\AppData\Roaming\Typora\typora-user-images\image-20221020190402422.png)

上面这行，&匹配上了，所以也对了

* System.out.println("b".matches("[a-z&&[def]]"));//相当于：是不是def

* System.out.println("0".matches("[a-z&&[ ^m-p]]"));相当于：a-z间除了m-p之外的范围

**预定义字符**

* \ 转义字符

  > 改变后面那个字符原本的含义
	>
	> 比如System.out.println("\\"");
	
* \\\\:前面的\是一个转义字符，改变了后面\原本的含义，把他变成一个普普通通的\而己。

![image-20221020193426811](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020193426811.png)

> 两个.表示两个字符是啥都行

![image-20221020193758478](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020193758478.png)

### 编写思路

拿着一个正确的数据，从左到右依次去写

**验证手机号码 **

* 1    只能1开头
* [3-9]    手机号码第二位只能3-9之间的
* \\\\d{9}    剩下数字只能出现9次，什么素质都行

```java
String regex1 = "1[3-9]\\d{9}";
System.out.println("15360598699".matches(regex1));
```

**验证座机号码**

1. 区号    0\\\\d{2,3}    0开头，后面加上2-3位任意数字
2. \-    ?表示可以出现0到1次
3. 号码    号码的第一位也不能以0开头，从第二位开始可以是任意的数字，号码的总长度：5-10位

```java
String regex2 = "0\\d{2,3}-?[1-9]\\d{4,9}";
```

**验证邮箱号码**

![image-20221020200823350](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020200823350.png)

### 高效使用any-rule

==在实际开发中，很少会自己写正则表达式。一般会百度一个类似的，自己改成公司要求的。==

先写一个：

```java
String regex = "";
```

鼠标点俩引号中间，然后点anyrule，把自动去除首尾斜杠勾了

我们先搜个 “ 时间 ”

```java
String regex = "^(?:1[0-2]|0?[1-9]):[0-5]\d:[0-5]\d$";
```

再把首尾的^和$去掉

```java
String regex = "(?:1[0-2]|0?[1-9]):[0-5]\d:[0-5]\d";
```

每个\后面再加一个\

```java
String regex = "(?:1[0-2]|0?[1-9]):[0-5]\\d:[0-5]\\d";
```

?:删掉

```java
String regex = "(1[0-2]|0?[1-9]):[0-5]\\d:[0-5]\\d";
```

### 最后一篇没看

【黑马程序员Java零基础视频教程_上部(2022新版Java入门，含斯坦福大学练习题+力扣算法题+大厂java面试题）】 https://www.bilibili.com/video/BV17F411T7Ao?p=165&share_source=copy_web&vd_source=a509fb44c892c9c55cbccbacad6d249b

## 爬虫（当然了，没python好用）

![image-20221020204831629](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020204831629.png)

![image-20221020205104603](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020205104603.png)

然后把所有代码抽取成一个方法，ctrl+alt+m

![image-20221020205311947](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020205311947.png)

当find返回false，循环停止  

### 后面部分没看完

【黑马程序员Java零基础视频教程_上部(2022新版Java入门，含斯坦福大学练习题+力扣算法题+大厂java面试题）】 【精准空降到 13:33】 https://www.bilibili.com/video/BV17F411T7Ao?p=166&share_source=copy_web&vd_source=a509fb44c892c9c55cbccbacad6d249b&t=813

## 包装类

### ====表示比较地址值是否相等==

![image-20221020211152496](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020211152496.png)

![image-20221020211352359](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020211352359.png)

### next()与nextLine

[关于nextInt()、next()和nextLine()的用法_小霸王学习机_001的博客-CSDN博客_nextint怎么用](https://blog.csdn.net/weixin_45156514/article/details/123553442)

[sc.next() 和 sc.nextLine 的区别_csdn_9527666的博客-CSDN博客_sc.nextline](https://blog.csdn.net/csdn_9527666/article/details/77917047)

==next()碰到分隔符结束==

==nextInt()等碰到回车\n或空格就结束*,只读取回车前输入的对应类型数值==

==nextLine碰到回车结束==

==所以在next()和NextInt()等方法后面用nextLine()时，要先拿个nextLine()吃掉前面剩的回车或空格==

所以

![image-20221020211737525](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020211737525.png)

==以后不管什么样的数据，统一nextLine()，先把数据录入内存当中，以后想要什么转换就完事了==

## 综合练习

>  键盘录入一些1-100之间的整数，并添加到集合中，直到集合中所有数据和超过200为止。

![image-20221020215130077](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221020215130077.png)

# 常见算法

## 查找

==返回多个数据时，我们可以把这些数据添加到数组或集合中==

**都要先排序**

### 二分查找

![image-20221021135500077](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021135500077.png)

### 插值查找

**优点**：算mid更快

**缺点**：要求数组数据分布要比较均匀

![image-20221021140003793](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021140003793.png)

### 斐波那契查找

mid不在中间了，改成0.618

### 分块查找

==这个算法直接这样用的场景非常少，主要是分块的这种思想在很多地方有用==

**分块原则：**

* 前一块中的最大数据，小于后一块中所有的数据（块内无序，块间有序）

* 块数数量一般等于数字的个数开根号。比如：16个数字一般分为4块左右

> 7 10 | 13 19 16 20 | 27 22 30 40 36 | 43 50 48

**先确定要查找的元素在哪一块，然后在块内挨个查找**

![image-20221021190247098](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021190247098.png)

![image-20221021190449071](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021190449071.png)

==后面块内元素大小必须比前面块内的大==

![image-20221021192106272](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021192106272.png)

给Block类来个快速生成

### 扩展的分块查找 -> 哈希查找（对无规律的数据）

==每一块数据范围不能有交集==

![image-20221021192958243](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021192958243.png)

一些变更

![image-20221021193313014](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021193313014.png)

![image-20221021193731089](C:/Users/84185/AppData/Roaming/Typora/typora-user-images/image-20221021193731089.png)